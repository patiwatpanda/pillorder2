// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/patiwatpanda/app/ent/dentist"
	"github.com/patiwatpanda/app/ent/employee"
	"github.com/patiwatpanda/app/ent/patient"
	"github.com/patiwatpanda/app/ent/pillorder"
	"github.com/patiwatpanda/app/ent/pillorderitem"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDentist       = "Dentist"
	TypeEmployee      = "Employee"
	TypePatient       = "Patient"
	TypePillorder     = "Pillorder"
	TypePillorderItem = "PillorderItem"
)

// DentistMutation represents an operation that mutate the Dentists
// nodes in the graph.
type DentistMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Dentist_name     *string
	clearedFields     map[string]struct{}
	pillorders        map[int]struct{}
	removedpillorders map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Dentist, error)
}

var _ ent.Mutation = (*DentistMutation)(nil)

// dentistOption allows to manage the mutation configuration using functional options.
type dentistOption func(*DentistMutation)

// newDentistMutation creates new mutation for $n.Name.
func newDentistMutation(c config, op Op, opts ...dentistOption) *DentistMutation {
	m := &DentistMutation{
		config:        c,
		op:            op,
		typ:           TypeDentist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDentistID sets the id field of the mutation.
func withDentistID(id int) dentistOption {
	return func(m *DentistMutation) {
		var (
			err   error
			once  sync.Once
			value *Dentist
		)
		m.oldValue = func(ctx context.Context) (*Dentist, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dentist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDentist sets the old Dentist of the mutation.
func withDentist(node *Dentist) dentistOption {
	return func(m *DentistMutation) {
		m.oldValue = func(context.Context) (*Dentist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DentistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DentistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DentistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDentistName sets the Dentist_name field.
func (m *DentistMutation) SetDentistName(s string) {
	m._Dentist_name = &s
}

// DentistName returns the Dentist_name value in the mutation.
func (m *DentistMutation) DentistName() (r string, exists bool) {
	v := m._Dentist_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDentistName returns the old Dentist_name value of the Dentist.
// If the Dentist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DentistMutation) OldDentistName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDentistName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDentistName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDentistName: %w", err)
	}
	return oldValue.DentistName, nil
}

// ResetDentistName reset all changes of the "Dentist_name" field.
func (m *DentistMutation) ResetDentistName() {
	m._Dentist_name = nil
}

// AddPillorderIDs adds the pillorders edge to Pillorder by ids.
func (m *DentistMutation) AddPillorderIDs(ids ...int) {
	if m.pillorders == nil {
		m.pillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.pillorders[ids[i]] = struct{}{}
	}
}

// RemovePillorderIDs removes the pillorders edge to Pillorder by ids.
func (m *DentistMutation) RemovePillorderIDs(ids ...int) {
	if m.removedpillorders == nil {
		m.removedpillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpillorders[ids[i]] = struct{}{}
	}
}

// RemovedPillorders returns the removed ids of pillorders.
func (m *DentistMutation) RemovedPillordersIDs() (ids []int) {
	for id := range m.removedpillorders {
		ids = append(ids, id)
	}
	return
}

// PillordersIDs returns the pillorders ids in the mutation.
func (m *DentistMutation) PillordersIDs() (ids []int) {
	for id := range m.pillorders {
		ids = append(ids, id)
	}
	return
}

// ResetPillorders reset all changes of the "pillorders" edge.
func (m *DentistMutation) ResetPillorders() {
	m.pillorders = nil
	m.removedpillorders = nil
}

// Op returns the operation name.
func (m *DentistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dentist).
func (m *DentistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DentistMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Dentist_name != nil {
		fields = append(fields, dentist.FieldDentistName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DentistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dentist.FieldDentistName:
		return m.DentistName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DentistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dentist.FieldDentistName:
		return m.OldDentistName(ctx)
	}
	return nil, fmt.Errorf("unknown Dentist field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DentistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dentist.FieldDentistName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDentistName(v)
		return nil
	}
	return fmt.Errorf("unknown Dentist field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DentistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DentistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DentistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dentist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DentistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DentistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DentistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dentist nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DentistMutation) ResetField(name string) error {
	switch name {
	case dentist.FieldDentistName:
		m.ResetDentistName()
		return nil
	}
	return fmt.Errorf("unknown Dentist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DentistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pillorders != nil {
		edges = append(edges, dentist.EdgePillorders)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DentistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dentist.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.pillorders))
		for id := range m.pillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DentistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpillorders != nil {
		edges = append(edges, dentist.EdgePillorders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DentistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dentist.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.removedpillorders))
		for id := range m.removedpillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DentistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DentistMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DentistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dentist unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DentistMutation) ResetEdge(name string) error {
	switch name {
	case dentist.EdgePillorders:
		m.ResetPillorders()
		return nil
	}
	return fmt.Errorf("unknown Dentist edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	employee_name     *string
	employee_email    *string
	employee_password *string
	clearedFields     map[string]struct{}
	pillorders        map[int]struct{}
	removedpillorders map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmployeeName sets the employee_name field.
func (m *EmployeeMutation) SetEmployeeName(s string) {
	m.employee_name = &s
}

// EmployeeName returns the employee_name value in the mutation.
func (m *EmployeeMutation) EmployeeName() (r string, exists bool) {
	v := m.employee_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old employee_name value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ResetEmployeeName reset all changes of the "employee_name" field.
func (m *EmployeeMutation) ResetEmployeeName() {
	m.employee_name = nil
}

// SetEmployeeEmail sets the employee_email field.
func (m *EmployeeMutation) SetEmployeeEmail(s string) {
	m.employee_email = &s
}

// EmployeeEmail returns the employee_email value in the mutation.
func (m *EmployeeMutation) EmployeeEmail() (r string, exists bool) {
	v := m.employee_email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeEmail returns the old employee_email value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeEmail: %w", err)
	}
	return oldValue.EmployeeEmail, nil
}

// ResetEmployeeEmail reset all changes of the "employee_email" field.
func (m *EmployeeMutation) ResetEmployeeEmail() {
	m.employee_email = nil
}

// SetEmployeePassword sets the employee_password field.
func (m *EmployeeMutation) SetEmployeePassword(s string) {
	m.employee_password = &s
}

// EmployeePassword returns the employee_password value in the mutation.
func (m *EmployeeMutation) EmployeePassword() (r string, exists bool) {
	v := m.employee_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePassword returns the old employee_password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeePassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePassword: %w", err)
	}
	return oldValue.EmployeePassword, nil
}

// ResetEmployeePassword reset all changes of the "employee_password" field.
func (m *EmployeeMutation) ResetEmployeePassword() {
	m.employee_password = nil
}

// AddPillorderIDs adds the pillorders edge to Pillorder by ids.
func (m *EmployeeMutation) AddPillorderIDs(ids ...int) {
	if m.pillorders == nil {
		m.pillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.pillorders[ids[i]] = struct{}{}
	}
}

// RemovePillorderIDs removes the pillorders edge to Pillorder by ids.
func (m *EmployeeMutation) RemovePillorderIDs(ids ...int) {
	if m.removedpillorders == nil {
		m.removedpillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpillorders[ids[i]] = struct{}{}
	}
}

// RemovedPillorders returns the removed ids of pillorders.
func (m *EmployeeMutation) RemovedPillordersIDs() (ids []int) {
	for id := range m.removedpillorders {
		ids = append(ids, id)
	}
	return
}

// PillordersIDs returns the pillorders ids in the mutation.
func (m *EmployeeMutation) PillordersIDs() (ids []int) {
	for id := range m.pillorders {
		ids = append(ids, id)
	}
	return
}

// ResetPillorders reset all changes of the "pillorders" edge.
func (m *EmployeeMutation) ResetPillorders() {
	m.pillorders = nil
	m.removedpillorders = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employee_name != nil {
		fields = append(fields, employee.FieldEmployeeName)
	}
	if m.employee_email != nil {
		fields = append(fields, employee.FieldEmployeeEmail)
	}
	if m.employee_password != nil {
		fields = append(fields, employee.FieldEmployeePassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeeName:
		return m.EmployeeName()
	case employee.FieldEmployeeEmail:
		return m.EmployeeEmail()
	case employee.FieldEmployeePassword:
		return m.EmployeePassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case employee.FieldEmployeeEmail:
		return m.OldEmployeeEmail(ctx)
	case employee.FieldEmployeePassword:
		return m.OldEmployeePassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case employee.FieldEmployeeEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeEmail(v)
		return nil
	case employee.FieldEmployeePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case employee.FieldEmployeeEmail:
		m.ResetEmployeeEmail()
		return nil
	case employee.FieldEmployeePassword:
		m.ResetEmployeePassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pillorders != nil {
		edges = append(edges, employee.EdgePillorders)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.pillorders))
		for id := range m.pillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpillorders != nil {
		edges = append(edges, employee.EdgePillorders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.removedpillorders))
		for id := range m.removedpillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgePillorders:
		m.ResetPillorders()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// PatientMutation represents an operation that mutate the Patients
// nodes in the graph.
type PatientMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Patient_name     *string
	_Patient_age      *int
	add_Patient_age   *int
	clearedFields     map[string]struct{}
	pillorders        map[int]struct{}
	removedpillorders map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Patient, error)
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows to manage the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for $n.Name.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the id field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPatientName sets the Patient_name field.
func (m *PatientMutation) SetPatientName(s string) {
	m._Patient_name = &s
}

// PatientName returns the Patient_name value in the mutation.
func (m *PatientMutation) PatientName() (r string, exists bool) {
	v := m._Patient_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientName returns the old Patient_name value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientName: %w", err)
	}
	return oldValue.PatientName, nil
}

// ResetPatientName reset all changes of the "Patient_name" field.
func (m *PatientMutation) ResetPatientName() {
	m._Patient_name = nil
}

// SetPatientAge sets the Patient_age field.
func (m *PatientMutation) SetPatientAge(i int) {
	m._Patient_age = &i
	m.add_Patient_age = nil
}

// PatientAge returns the Patient_age value in the mutation.
func (m *PatientMutation) PatientAge() (r int, exists bool) {
	v := m._Patient_age
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientAge returns the old Patient_age value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientAge: %w", err)
	}
	return oldValue.PatientAge, nil
}

// AddPatientAge adds i to Patient_age.
func (m *PatientMutation) AddPatientAge(i int) {
	if m.add_Patient_age != nil {
		*m.add_Patient_age += i
	} else {
		m.add_Patient_age = &i
	}
}

// AddedPatientAge returns the value that was added to the Patient_age field in this mutation.
func (m *PatientMutation) AddedPatientAge() (r int, exists bool) {
	v := m.add_Patient_age
	if v == nil {
		return
	}
	return *v, true
}

// ResetPatientAge reset all changes of the "Patient_age" field.
func (m *PatientMutation) ResetPatientAge() {
	m._Patient_age = nil
	m.add_Patient_age = nil
}

// AddPillorderIDs adds the pillorders edge to Pillorder by ids.
func (m *PatientMutation) AddPillorderIDs(ids ...int) {
	if m.pillorders == nil {
		m.pillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.pillorders[ids[i]] = struct{}{}
	}
}

// RemovePillorderIDs removes the pillorders edge to Pillorder by ids.
func (m *PatientMutation) RemovePillorderIDs(ids ...int) {
	if m.removedpillorders == nil {
		m.removedpillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpillorders[ids[i]] = struct{}{}
	}
}

// RemovedPillorders returns the removed ids of pillorders.
func (m *PatientMutation) RemovedPillordersIDs() (ids []int) {
	for id := range m.removedpillorders {
		ids = append(ids, id)
	}
	return
}

// PillordersIDs returns the pillorders ids in the mutation.
func (m *PatientMutation) PillordersIDs() (ids []int) {
	for id := range m.pillorders {
		ids = append(ids, id)
	}
	return
}

// ResetPillorders reset all changes of the "pillorders" edge.
func (m *PatientMutation) ResetPillorders() {
	m.pillorders = nil
	m.removedpillorders = nil
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Patient_name != nil {
		fields = append(fields, patient.FieldPatientName)
	}
	if m._Patient_age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientName:
		return m.PatientName()
	case patient.FieldPatientAge:
		return m.PatientAge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPatientName:
		return m.OldPatientName(ctx)
	case patient.FieldPatientAge:
		return m.OldPatientAge(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientName(v)
		return nil
	case patient.FieldPatientAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientAge(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.add_Patient_age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientAge:
		return m.AddedPatientAge()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatientAge(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPatientName:
		m.ResetPatientName()
		return nil
	case patient.FieldPatientAge:
		m.ResetPatientAge()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pillorders != nil {
		edges = append(edges, patient.EdgePillorders)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.pillorders))
		for id := range m.pillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpillorders != nil {
		edges = append(edges, patient.EdgePillorders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.removedpillorders))
		for id := range m.removedpillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgePillorders:
		m.ResetPillorders()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PillorderMutation represents an operation that mutate the Pillorders
// nodes in the graph.
type PillorderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_PillorderNameID     *string
	_PillorderDate       *time.Time
	clearedFields        map[string]struct{}
	employee             *int
	clearedemployee      bool
	patient              *int
	clearedpatient       bool
	dentist              *int
	cleareddentist       bool
	pillorderitem        *int
	clearedpillorderitem bool
	done                 bool
	oldValue             func(context.Context) (*Pillorder, error)
}

var _ ent.Mutation = (*PillorderMutation)(nil)

// pillorderOption allows to manage the mutation configuration using functional options.
type pillorderOption func(*PillorderMutation)

// newPillorderMutation creates new mutation for $n.Name.
func newPillorderMutation(c config, op Op, opts ...pillorderOption) *PillorderMutation {
	m := &PillorderMutation{
		config:        c,
		op:            op,
		typ:           TypePillorder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPillorderID sets the id field of the mutation.
func withPillorderID(id int) pillorderOption {
	return func(m *PillorderMutation) {
		var (
			err   error
			once  sync.Once
			value *Pillorder
		)
		m.oldValue = func(ctx context.Context) (*Pillorder, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pillorder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPillorder sets the old Pillorder of the mutation.
func withPillorder(node *Pillorder) pillorderOption {
	return func(m *PillorderMutation) {
		m.oldValue = func(context.Context) (*Pillorder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PillorderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PillorderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PillorderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPillorderNameID sets the PillorderNameID field.
func (m *PillorderMutation) SetPillorderNameID(s string) {
	m._PillorderNameID = &s
}

// PillorderNameID returns the PillorderNameID value in the mutation.
func (m *PillorderMutation) PillorderNameID() (r string, exists bool) {
	v := m._PillorderNameID
	if v == nil {
		return
	}
	return *v, true
}

// OldPillorderNameID returns the old PillorderNameID value of the Pillorder.
// If the Pillorder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PillorderMutation) OldPillorderNameID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPillorderNameID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPillorderNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPillorderNameID: %w", err)
	}
	return oldValue.PillorderNameID, nil
}

// ResetPillorderNameID reset all changes of the "PillorderNameID" field.
func (m *PillorderMutation) ResetPillorderNameID() {
	m._PillorderNameID = nil
}

// SetPillorderDate sets the PillorderDate field.
func (m *PillorderMutation) SetPillorderDate(t time.Time) {
	m._PillorderDate = &t
}

// PillorderDate returns the PillorderDate value in the mutation.
func (m *PillorderMutation) PillorderDate() (r time.Time, exists bool) {
	v := m._PillorderDate
	if v == nil {
		return
	}
	return *v, true
}

// OldPillorderDate returns the old PillorderDate value of the Pillorder.
// If the Pillorder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PillorderMutation) OldPillorderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPillorderDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPillorderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPillorderDate: %w", err)
	}
	return oldValue.PillorderDate, nil
}

// ResetPillorderDate reset all changes of the "PillorderDate" field.
func (m *PillorderMutation) ResetPillorderDate() {
	m._PillorderDate = nil
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *PillorderMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *PillorderMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *PillorderMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *PillorderMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PillorderMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *PillorderMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetPatientID sets the patient edge to Patient by id.
func (m *PillorderMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the patient edge to Patient.
func (m *PillorderMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the edge patient was cleared.
func (m *PillorderMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the patient id in the mutation.
func (m *PillorderMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PillorderMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "patient" edge.
func (m *PillorderMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetDentistID sets the dentist edge to Dentist by id.
func (m *PillorderMutation) SetDentistID(id int) {
	m.dentist = &id
}

// ClearDentist clears the dentist edge to Dentist.
func (m *PillorderMutation) ClearDentist() {
	m.cleareddentist = true
}

// DentistCleared returns if the edge dentist was cleared.
func (m *PillorderMutation) DentistCleared() bool {
	return m.cleareddentist
}

// DentistID returns the dentist id in the mutation.
func (m *PillorderMutation) DentistID() (id int, exists bool) {
	if m.dentist != nil {
		return *m.dentist, true
	}
	return
}

// DentistIDs returns the dentist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DentistID instead. It exists only for internal usage by the builders.
func (m *PillorderMutation) DentistIDs() (ids []int) {
	if id := m.dentist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDentist reset all changes of the "dentist" edge.
func (m *PillorderMutation) ResetDentist() {
	m.dentist = nil
	m.cleareddentist = false
}

// SetPillorderitemID sets the pillorderitem edge to PillorderItem by id.
func (m *PillorderMutation) SetPillorderitemID(id int) {
	m.pillorderitem = &id
}

// ClearPillorderitem clears the pillorderitem edge to PillorderItem.
func (m *PillorderMutation) ClearPillorderitem() {
	m.clearedpillorderitem = true
}

// PillorderitemCleared returns if the edge pillorderitem was cleared.
func (m *PillorderMutation) PillorderitemCleared() bool {
	return m.clearedpillorderitem
}

// PillorderitemID returns the pillorderitem id in the mutation.
func (m *PillorderMutation) PillorderitemID() (id int, exists bool) {
	if m.pillorderitem != nil {
		return *m.pillorderitem, true
	}
	return
}

// PillorderitemIDs returns the pillorderitem ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PillorderitemID instead. It exists only for internal usage by the builders.
func (m *PillorderMutation) PillorderitemIDs() (ids []int) {
	if id := m.pillorderitem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPillorderitem reset all changes of the "pillorderitem" edge.
func (m *PillorderMutation) ResetPillorderitem() {
	m.pillorderitem = nil
	m.clearedpillorderitem = false
}

// Op returns the operation name.
func (m *PillorderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pillorder).
func (m *PillorderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PillorderMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._PillorderNameID != nil {
		fields = append(fields, pillorder.FieldPillorderNameID)
	}
	if m._PillorderDate != nil {
		fields = append(fields, pillorder.FieldPillorderDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PillorderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pillorder.FieldPillorderNameID:
		return m.PillorderNameID()
	case pillorder.FieldPillorderDate:
		return m.PillorderDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PillorderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pillorder.FieldPillorderNameID:
		return m.OldPillorderNameID(ctx)
	case pillorder.FieldPillorderDate:
		return m.OldPillorderDate(ctx)
	}
	return nil, fmt.Errorf("unknown Pillorder field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PillorderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pillorder.FieldPillorderNameID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPillorderNameID(v)
		return nil
	case pillorder.FieldPillorderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPillorderDate(v)
		return nil
	}
	return fmt.Errorf("unknown Pillorder field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PillorderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PillorderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PillorderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pillorder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PillorderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PillorderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PillorderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pillorder nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PillorderMutation) ResetField(name string) error {
	switch name {
	case pillorder.FieldPillorderNameID:
		m.ResetPillorderNameID()
		return nil
	case pillorder.FieldPillorderDate:
		m.ResetPillorderDate()
		return nil
	}
	return fmt.Errorf("unknown Pillorder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PillorderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.employee != nil {
		edges = append(edges, pillorder.EdgeEmployee)
	}
	if m.patient != nil {
		edges = append(edges, pillorder.EdgePatient)
	}
	if m.dentist != nil {
		edges = append(edges, pillorder.EdgeDentist)
	}
	if m.pillorderitem != nil {
		edges = append(edges, pillorder.EdgePillorderitem)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PillorderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pillorder.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case pillorder.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case pillorder.EdgeDentist:
		if id := m.dentist; id != nil {
			return []ent.Value{*id}
		}
	case pillorder.EdgePillorderitem:
		if id := m.pillorderitem; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PillorderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PillorderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PillorderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedemployee {
		edges = append(edges, pillorder.EdgeEmployee)
	}
	if m.clearedpatient {
		edges = append(edges, pillorder.EdgePatient)
	}
	if m.cleareddentist {
		edges = append(edges, pillorder.EdgeDentist)
	}
	if m.clearedpillorderitem {
		edges = append(edges, pillorder.EdgePillorderitem)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PillorderMutation) EdgeCleared(name string) bool {
	switch name {
	case pillorder.EdgeEmployee:
		return m.clearedemployee
	case pillorder.EdgePatient:
		return m.clearedpatient
	case pillorder.EdgeDentist:
		return m.cleareddentist
	case pillorder.EdgePillorderitem:
		return m.clearedpillorderitem
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PillorderMutation) ClearEdge(name string) error {
	switch name {
	case pillorder.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case pillorder.EdgePatient:
		m.ClearPatient()
		return nil
	case pillorder.EdgeDentist:
		m.ClearDentist()
		return nil
	case pillorder.EdgePillorderitem:
		m.ClearPillorderitem()
		return nil
	}
	return fmt.Errorf("unknown Pillorder unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PillorderMutation) ResetEdge(name string) error {
	switch name {
	case pillorder.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case pillorder.EdgePatient:
		m.ResetPatient()
		return nil
	case pillorder.EdgeDentist:
		m.ResetDentist()
		return nil
	case pillorder.EdgePillorderitem:
		m.ResetPillorderitem()
		return nil
	}
	return fmt.Errorf("unknown Pillorder edge %s", name)
}

// PillorderItemMutation represents an operation that mutate the PillorderItems
// nodes in the graph.
type PillorderItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_PillorderItem_name *string
	clearedFields       map[string]struct{}
	pillorders          map[int]struct{}
	removedpillorders   map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*PillorderItem, error)
}

var _ ent.Mutation = (*PillorderItemMutation)(nil)

// pillorderitemOption allows to manage the mutation configuration using functional options.
type pillorderitemOption func(*PillorderItemMutation)

// newPillorderItemMutation creates new mutation for $n.Name.
func newPillorderItemMutation(c config, op Op, opts ...pillorderitemOption) *PillorderItemMutation {
	m := &PillorderItemMutation{
		config:        c,
		op:            op,
		typ:           TypePillorderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPillorderItemID sets the id field of the mutation.
func withPillorderItemID(id int) pillorderitemOption {
	return func(m *PillorderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *PillorderItem
		)
		m.oldValue = func(ctx context.Context) (*PillorderItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PillorderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPillorderItem sets the old PillorderItem of the mutation.
func withPillorderItem(node *PillorderItem) pillorderitemOption {
	return func(m *PillorderItemMutation) {
		m.oldValue = func(context.Context) (*PillorderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PillorderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PillorderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PillorderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPillorderItemName sets the PillorderItem_name field.
func (m *PillorderItemMutation) SetPillorderItemName(s string) {
	m._PillorderItem_name = &s
}

// PillorderItemName returns the PillorderItem_name value in the mutation.
func (m *PillorderItemMutation) PillorderItemName() (r string, exists bool) {
	v := m._PillorderItem_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPillorderItemName returns the old PillorderItem_name value of the PillorderItem.
// If the PillorderItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PillorderItemMutation) OldPillorderItemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPillorderItemName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPillorderItemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPillorderItemName: %w", err)
	}
	return oldValue.PillorderItemName, nil
}

// ResetPillorderItemName reset all changes of the "PillorderItem_name" field.
func (m *PillorderItemMutation) ResetPillorderItemName() {
	m._PillorderItem_name = nil
}

// AddPillorderIDs adds the pillorders edge to Pillorder by ids.
func (m *PillorderItemMutation) AddPillorderIDs(ids ...int) {
	if m.pillorders == nil {
		m.pillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.pillorders[ids[i]] = struct{}{}
	}
}

// RemovePillorderIDs removes the pillorders edge to Pillorder by ids.
func (m *PillorderItemMutation) RemovePillorderIDs(ids ...int) {
	if m.removedpillorders == nil {
		m.removedpillorders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpillorders[ids[i]] = struct{}{}
	}
}

// RemovedPillorders returns the removed ids of pillorders.
func (m *PillorderItemMutation) RemovedPillordersIDs() (ids []int) {
	for id := range m.removedpillorders {
		ids = append(ids, id)
	}
	return
}

// PillordersIDs returns the pillorders ids in the mutation.
func (m *PillorderItemMutation) PillordersIDs() (ids []int) {
	for id := range m.pillorders {
		ids = append(ids, id)
	}
	return
}

// ResetPillorders reset all changes of the "pillorders" edge.
func (m *PillorderItemMutation) ResetPillorders() {
	m.pillorders = nil
	m.removedpillorders = nil
}

// Op returns the operation name.
func (m *PillorderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PillorderItem).
func (m *PillorderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PillorderItemMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PillorderItem_name != nil {
		fields = append(fields, pillorderitem.FieldPillorderItemName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PillorderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pillorderitem.FieldPillorderItemName:
		return m.PillorderItemName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PillorderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pillorderitem.FieldPillorderItemName:
		return m.OldPillorderItemName(ctx)
	}
	return nil, fmt.Errorf("unknown PillorderItem field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PillorderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pillorderitem.FieldPillorderItemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPillorderItemName(v)
		return nil
	}
	return fmt.Errorf("unknown PillorderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PillorderItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PillorderItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PillorderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PillorderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PillorderItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PillorderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PillorderItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PillorderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PillorderItemMutation) ResetField(name string) error {
	switch name {
	case pillorderitem.FieldPillorderItemName:
		m.ResetPillorderItemName()
		return nil
	}
	return fmt.Errorf("unknown PillorderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PillorderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pillorders != nil {
		edges = append(edges, pillorderitem.EdgePillorders)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PillorderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pillorderitem.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.pillorders))
		for id := range m.pillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PillorderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpillorders != nil {
		edges = append(edges, pillorderitem.EdgePillorders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PillorderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pillorderitem.EdgePillorders:
		ids := make([]ent.Value, 0, len(m.removedpillorders))
		for id := range m.removedpillorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PillorderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PillorderItemMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PillorderItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PillorderItem unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PillorderItemMutation) ResetEdge(name string) error {
	switch name {
	case pillorderitem.EdgePillorders:
		m.ResetPillorders()
		return nil
	}
	return fmt.Errorf("unknown PillorderItem edge %s", name)
}
